#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  flipped,        sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  Left,           sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  Right,          sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           Left,          tmotorVex393HighSpeed_MC29, openLoop, driveLeft, encoderPort, I2C_2)
#pragma config(Motor,  port7,           flipped,       tmotorVex393TurboSpeed_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port8,           Right,         tmotorVex393HighSpeed_MC29, openLoop, driveRight, encoderPort, I2C_3)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//This uses the method of PIV control, where we also take velocity into account with position.
//In this loop, the velocity loop uses PI while the Position Loop uses P.

float encoder_counts;
float nSysTime_last;
float encoder_counts_last;
float motor_velocity;
float velocity_error;
float target_velocity;
float position_error;
float Proportion;
float Integral;
float Derivative;
float value;
float target;
float lastError;

long FwMotorEncoderGet()
{
	return( nMotorEncoder[ port7 ] );
}
	
int inchToTicks (float inch)
{
	int ticks;
	ticks = inch*62.4;
	return ticks;
}

void setBaseSpeed( int value )
{
	motor[port2] = value;
	motor[port3] = value;
	motor[port8] = value;
	motor[port9] = value;
}

void VelocityCalculateError()
{
	   int     delta_ms;
	   int     delta_enc;

	   encoder_counts = FwMotorEncoderGet();
	   delta_ms = nSysTime - nSysTime_last;
	   nSysTime_last = nSysTime;
		 delta_enc = (encoder_counts - encoder_counts_last);
		 encoder_counts_last = encoder_counts;
 		 motor_velocity = (1000.0 / delta_ms) * delta_enc * 60.0 / 392;	//ticks per rev is based on 1.6:1 internal gearing
 		 
 		 velocity_error = target_velocity - motor_velocity;
}

void PositionCaculateError()
{
		position_error = inchToTicks(target) - (nMotorEncoder[Left] + nMotorEncoder[Right]);
}

void PIVControl (float target, float target_velocity)
{
		float kp = 0.01;
		float ki = 0.01;
		float kd = 0.001;
		
		VelocityCalculateError();
		PositionCaculateError();
	
		Proportion = position_error * kp;
		Integral = (Integral + position_error) * ki;
		
		Derivative = (velocity_error - lastError) * kd;
		
		value = Proportion + Integral + Derivative;
		setBaseSpeed (value);
		wait1Msec(20);
		
		lastError = velocity_error;
}

task main()
{
	PIVControl(50, 5);
}
